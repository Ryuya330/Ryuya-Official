<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Opening Animation</title>
    
    <!-- External Libraries & Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
    
    <!-- JS Libraries for Animation & Sound -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <style>
        :root {
            --accent-color: #ff00ff;
        }
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        #opening-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            background: #000;
            cursor: none;
        }
        .opening-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
            opacity: 0;
            transition: opacity 1.5s cubic-bezier(0.23, 1, 0.32, 1);
        }
        .opening-canvas.visible {
            opacity: 1;
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            pointer-events: none;
            z-index: 50;
            padding: 20px;
            box-sizing: border-box;
        }
        .ui-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #activation-button {
            padding: 18px 36px;
            font-size: 1.5em;
            font-family: 'Orbitron', sans-serif;
            background: transparent;
            color: #00cde9;
            border: 2px solid #00cde9;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            position: relative;
            overflow: hidden;
            transition: color 0.3s, background-color 0.3s, box-shadow 0.3s, transform 0.3s;
            text-shadow: 0 0 10px #00cde9;
        }
        #activation-button:hover {
            background-color: #00cde9;
            color: #000;
            box-shadow: 0 0 25px #00cde9, 0 0 50px #00cde9;
            transform: scale(1.05);
        }
        #info-text {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1rem, 3.5vw, 2.2rem);
            color: #fff;
            text-shadow: 0 0 8px #fff, 0 0 15px var(--accent-color);
            margin-top: 20px;
            text-align: center;
            transition: opacity 0.5s ease-out;
            letter-spacing: 2px;
        }
        #info-text.fade-out {
            opacity: 0;
        }
        #info-text .cursor {
            display: inline-block;
            background-color: #fff;
            box-shadow: 0 0 8px #fff;
            width: 12px;
            height: 1.2em;
            animation: blink 1s infinite;
            margin-left: 8px;
            vertical-align: middle;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="opening-container">
        <canvas id="opening-canvas-1" class="opening-canvas" style="z-index: 1;"></canvas>
        <canvas id="opening-canvas-2" class="opening-canvas" style="z-index: 2;"></canvas>
        <canvas id="opening-canvas-3" class="opening-canvas" style="z-index: 3;"></canvas>
        <canvas id="opening-canvas-4" class="opening-canvas" style="z-index: 4;"></canvas>
        <div id="ui-overlay" class="ui-overlay">
            <button id="activation-button">ACTIVATE SYSTEM</button>
            <p id="info-text"></p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const openingContainer = document.getElementById('opening-container');
            const canvases = [
                document.getElementById('opening-canvas-1'),
                document.getElementById('opening-canvas-2'),
                document.getElementById('opening-canvas-3'),
                document.getElementById('opening-canvas-4')
            ];
            const uiOverlay = document.getElementById('ui-overlay');
            const activationButton = document.getElementById('activation-button');
            const infoText = document.getElementById('info-text');

            let activeAnimation = null;
            let sounds = {};
            let typeIntervalHandle = null;

            const setupSounds = () => {
                try {
                    const reverb = new Tone.Reverb(1.5).toDestination();
                    const delay = new Tone.FeedbackDelay("8n", 0.25).connect(reverb);
                    sounds.bleep = new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 4, envelope: { attack: 0.001, decay: 0.1, sustain: 0 } }).toDestination();
                    sounds.bleep.volume.value = -12;
                    sounds.boot = new Tone.MetalSynth({ frequency: 50, envelope: { attack: 0.001, decay: 1.4, release: 0.2 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).connect(delay);
                    sounds.boot.volume.value = -15;
                    sounds.access = new Tone.PluckSynth({ attackNoise: 0.5, dampening: 4000, resonance: 0.9 }).toDestination();
                    sounds.access.volume.value = -8;
                    sounds.music = new Tone.AMSynth({ harmonicity: 1.5, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 }, modulation: { type: "sine" }, modulationEnvelope: { attack: 0.1, decay: 0.1, sustain: 0.3, release: 0.5 } }).connect(reverb);
                    sounds.matrix = new Tone.PluckSynth({ volume: -20, attackNoise: 0.8, dampening: 6000, resonance: 0.7 }).toDestination();
                    sounds.lockon = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 } }).toDestination();
                    sounds.lockon.volume.value = -10;
                    sounds.success = new Tone.Synth({ oscillator: { type: 'triangle8' }, envelope: { attack: 0.01, decay: 0.4, sustain: 0.2, release: 0.4 } }).toDestination();
                    sounds.success.volume.value = -8;
                    sounds.portal = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.5, decay: 1.0, sustain: 0.2, release: 1.0 } }).connect(reverb);
                    sounds.portal.volume.value = -10;
                    const filter = new Tone.Filter(800, "lowpass").connect(reverb);
                    sounds.bgmCircuit = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 1, decay: 0.5, sustain: 1 } }).connect(filter);
                    sounds.bgmCircuit.volume.value = -22;
                    const chorus = new Tone.Chorus(4, 2.5, 0.5).toDestination();
                    sounds.bgmScan = new Tone.AMSynth({ harmonicity: 1.2, envelope: { attack: 2, decay: 1, sustain: 1, release: 2 }, modulation: { type: "sine" }, modulationEnvelope: { attack: 2, decay: 0.5, sustain: 1, release: 2 } }).connect(chorus);
                    sounds.bgmScan.volume.value = -18;
                    sounds.bgmCreator = new Tone.FatOscillator("Ab3", "sawtooth", 40).connect(reverb);
                    sounds.bgmCreator.volume.value = -22;
                    sounds.bgmMatrix = new Tone.Loop(time => { sounds.boot.triggerAttackRelease("C1", "2n", time); }, "4m");
                } catch (e) { console.error("Error setting up Tone.js sounds:", e); }
            };

            const typeWriter = (text, element) => {
                if (typeIntervalHandle) clearInterval(typeIntervalHandle);
                return new Promise(resolve => {
                    element.innerHTML = '<span class="cursor"></span>';
                    const cursor = element.querySelector('.cursor');
                    let i = 0;
                    typeIntervalHandle = setInterval(() => {
                        if (i < text.length) {
                            element.insertBefore(document.createTextNode(text.charAt(i)), cursor);
                            if (sounds.bleep && Tone.context.state === 'running') sounds.bleep.triggerAttackRelease("C2", "32n", Tone.now() + i * 0.01);
                            i++;
                        } else {
                            clearInterval(typeIntervalHandle);
                            typeIntervalHandle = null;
                            resolve();
                        }
                    }, 80);
                });
            };

            const switchAnimation = (newAnimation) => {
                return new Promise(resolve => {
                    if (activeAnimation && activeAnimation.stop) {
                        activeAnimation.stop();
                    }
                    activeAnimation = newAnimation;
                    if (activeAnimation && activeAnimation.start) {
                        activeAnimation.start().then(resolve);
                    } else {
                        resolve();
                    }
                });
            };

            const animations = {
                circuit: {
                    ctx: canvases[0].getContext('2d'),
                    nodes: [], edges: [], pulses: [], cancelId: 0,
                    start() {
                        canvases[0].classList.add('visible');
                        this.resize();
                        this.nodes = []; this.edges = []; this.pulses = [];
                        const gridSize = 10;
                        const spacingX = this.ctx.canvas.width / gridSize;
                        const spacingY = this.ctx.canvas.height / gridSize;
                        for (let i = 0; i <= gridSize; i++) {
                            for (let j = 0; j <= gridSize; j++) {
                                this.nodes.push({ x: i * spacingX, y: j * spacingY });
                            }
                        }
                        for (let i = 0; i < this.nodes.length; i++) {
                            for (let j = i + 1; j < this.nodes.length; j++) {
                                if (Math.random() > 0.95) this.edges.push({ from: i, to: j });
                            }
                        }
                        setInterval(() => {
                            if (this.pulses.length < 20) {
                                const edge = this.edges[Math.floor(Math.random() * this.edges.length)];
                                this.pulses.push({ edge: edge, progress: 0 });
                            }
                        }, 100);
                        if(sounds.boot) sounds.boot.triggerAttackRelease("C1", "2n");
                        if(sounds.bgmCircuit) sounds.bgmCircuit.triggerAttack();
                        this.animate();
                        return Promise.resolve();
                    },
                    stop() {
                        cancelAnimationFrame(this.cancelId);
                        if(sounds.bgmCircuit) sounds.bgmCircuit.triggerRelease();
                        canvases[0].classList.remove('visible');
                    },
                    resize() {
                        canvases[0].width = window.innerWidth;
                        canvases[0].height = window.innerHeight;
                    },
                    animate() {
                        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
                        this.ctx.fillStyle = "rgba(0, 205, 233, 0.3)";
                        this.nodes.forEach(node => { this.ctx.beginPath(); this.ctx.arc(node.x, node.y, 2, 0, Math.PI * 2); this.ctx.fill(); });
                        this.ctx.strokeStyle = "rgba(0, 205, 233, 0.1)";
                        this.edges.forEach(edge => {
                            const from = this.nodes[edge.from]; const to = this.nodes[edge.to];
                            this.ctx.beginPath(); this.ctx.moveTo(from.x, from.y); this.ctx.lineTo(to.x, to.y); this.ctx.stroke();
                        });
                        this.ctx.fillStyle = "#ff00ff";
                        this.pulses.forEach((pulse, index) => {
                            const from = this.nodes[pulse.edge.from]; const to = this.nodes[pulse.edge.to];
                            const x = from.x + (to.x - from.x) * pulse.progress;
                            const y = from.y + (to.y - from.y) * pulse.progress;
                            this.ctx.beginPath(); this.ctx.arc(x, y, 3, 0, Math.PI * 2); this.ctx.fill();
                            pulse.progress += 0.02;
                            if (pulse.progress >= 1) { this.pulses.splice(index, 1); }
                        });
                        this.cancelId = requestAnimationFrame(this.animate.bind(this));
                    }
                },
                biometricScan: {
                    scene: new THREE.Scene(),
                    camera: new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000),
                    renderer: new THREE.WebGLRenderer({ canvas: canvases[1], alpha: true }),
                    head: null, scanPlane: null, dna: null, cancelId: 0, startTime: 0, isSuccess: false,
                    start() {
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                        this.renderer.setPixelRatio(window.devicePixelRatio);
                        canvases[1].classList.add('visible');
                        const geometry = new THREE.SphereGeometry(1.5, 32, 16);
                        const position = geometry.attributes.position;
                        for (let i = 0; i < position.count; i++) {
                            let v = new THREE.Vector3().fromBufferAttribute(position, i);
                            v.y *= 1.2; v.z *= 0.8;
                            position.setXYZ(i, v.x, v.y, v.z);
                        }
                        const material = new THREE.MeshPhongMaterial({ color: 0x00cde9, wireframe: true, shininess: 80 });
                        this.head = new THREE.Mesh(geometry, material);
                        this.scene.add(this.head);
                        const planeGeo = new THREE.PlaneGeometry(5, 0.1);
                        const planeMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, side: THREE.DoubleSide, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending });
                        this.scanPlane = new THREE.Mesh(planeGeo, planeMat);
                        this.scanPlane.position.y = 2.5;
                        this.scene.add(this.scanPlane);
                        const curve = new THREE.CatmullRomCurve3(
                            Array.from({length: 100}, (_, i) => new THREE.Vector3(Math.sin(i * 0.2) * 0.5, i * 0.1 - 5, Math.cos(i * 0.2) * 0.5))
                        );
                        const tubeGeo = new THREE.TubeGeometry(curve, 100, 0.05, 8, false);
                        const tubeMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
                        this.dna = new THREE.Mesh(tubeGeo, tubeMat);
                        this.dna.position.x = -2.5;
                        this.scene.add(this.dna);
                        this.scene.add(new THREE.AmbientLight(0xffffff, 0.2));
                        const pointLight = new THREE.PointLight(0x00cde9, 1);
                        pointLight.position.set(5, 5, 5);
                        this.scene.add(pointLight);
                        this.camera.position.z = 5;
                        this.startTime = Date.now();
                        this.isSuccess = false;
                        if(sounds.lockon) sounds.lockon.triggerAttackRelease("A4", "8n");
                        if(sounds.bgmScan) sounds.bgmScan.triggerAttack("C2");
                        this.animate();
                        return Promise.resolve();
                    },
                    stop() {
                        cancelAnimationFrame(this.cancelId);
                        if(sounds.bgmScan) sounds.bgmScan.triggerRelease();
                        canvases[1].classList.remove('visible');
                        while(this.scene.children.length > 0){ this.scene.remove(this.scene.children[0]); }
                    },
                    setSuccess() {
                        this.isSuccess = true;
                        if (this.head) { 
                            this.head.material.wireframe = false;
                            this.head.material.color.set(0x00ff00); 
                            this.head.material.emissive = new THREE.Color(0x00ff00);
                            this.head.material.emissiveIntensity = 0.5;
                        }
                        if(sounds.success) {
                            sounds.success.triggerAttackRelease("C5", "8n", Tone.now());
                            sounds.success.triggerAttackRelease("G5", "8n", Tone.now() + 0.1);
                        }
                    },
                    animate() {
                        this.cancelId = requestAnimationFrame(this.animate.bind(this));
                        this.head.rotation.y += 0.005;
                        this.dna.rotation.y += 0.02;
                        if (!this.isSuccess) {
                            const scanDuration = 4000;
                            const progress = ((Date.now() - this.startTime) % scanDuration) / scanDuration;
                            this.scanPlane.position.y = 2.5 - (progress * 5);
                        }
                        if (this.isSuccess) {
                            const intensity = 0.5 + Math.sin(Date.now() * 0.01) * 0.5;
                            this.head.material.emissiveIntensity = intensity;
                        }
                        this.renderer.render(this.scene, this.camera);
                    }
                },
                creatorWorld: {
                    scene: new THREE.Scene(),
                    camera: new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000),
                    renderer: new THREE.WebGLRenderer({ canvas: canvases[2], alpha: true }),
                    particles: null, cancelId: 0, clock: new THREE.Clock(),
                    start() {
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                        this.renderer.setPixelRatio(window.devicePixelRatio);
                        this.camera.position.set(0, 0, 100);
                        const geometry = new THREE.BufferGeometry();
                        const numParticles = 50000;
                        const positions = new Float32Array(numParticles * 3);
                        const colors = new Float32Array(numParticles * 3);
                        const color = new THREE.Color();
                        for (let i = 0; i < numParticles; i++) {
                            const radius = Math.random() * 200 + 50;
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.acos((Math.random() * 2) - 1);
                            positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                            positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                            positions[i * 3 + 2] = radius * Math.cos(phi);
                            color.setHSL(Math.random(), 0.8, 0.6);
                            colors[i * 3] = color.r; colors[i * 3 + 1] = color.g; colors[i * 3 + 2] = color.b;
                        }
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                        const material = new THREE.PointsMaterial({ size: 0.8, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true });
                        this.particles = new THREE.Points(geometry, material);
                        this.scene.add(this.particles);
                        if(sounds.bgmCreator) sounds.bgmCreator.start();
                        canvases[2].classList.add('visible');
                        this.animate();
                        return new Promise(res => setTimeout(res, 500));
                    },
                    stop() {
                        cancelAnimationFrame(this.cancelId);
                        if(sounds.bgmCreator) sounds.bgmCreator.stop();
                        canvases[2].classList.remove('visible');
                    },
                    animate() {
                        const delta = this.clock.getDelta();
                        this.particles.rotation.x += delta * 0.05;
                        this.particles.rotation.y += delta * 0.1;
                        this.renderer.render(this.scene, this.camera);
                        this.cancelId = requestAnimationFrame(this.animate.bind(this));
                    }
                },
                musicWorld: {
                    scene: new THREE.Scene(),
                    camera: new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000),
                    renderer: new THREE.WebGLRenderer({ canvas: canvases[3], alpha: true }),
                    analyser: null, plane: null, cancelId: 0, clock: new THREE.Clock(),
                    start() {
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                        this.renderer.setPixelRatio(window.devicePixelRatio);
                        this.camera.position.set(0, 10, 0);
                        this.camera.lookAt(0,0,-50);
                        this.analyser = new Tone.Analyser('waveform', 1024);
                        sounds.music.connect(this.analyser);
                        const geometry = new THREE.PlaneGeometry(100, 100, 50, 50);
                        const material = new THREE.MeshPhongMaterial({
                            color: 0x8139f5, specular: 0xff00ff, shininess: 50,
                            wireframe: true, transparent: true, opacity: 0.8
                        });
                        this.plane = new THREE.Mesh(geometry, material);
                        this.plane.rotation.x = -Math.PI / 2;
                        this.scene.add(this.plane);
                        const light = new THREE.PointLight(0xff00ff, 2, 100);
                        light.position.set(0, 20, 0);
                        this.scene.add(light);
                        const notes = ["C4", "E4", "G4", "B4", "D5"];
                        new Tone.Sequence((time, note) => {
                            sounds.music.triggerAttackRelease(note, "8n", time);
                        }, notes, "8n").start(0);
                        canvases[3].classList.add('visible');
                        this.animate();
                        return new Promise(res => setTimeout(res, 500));
                    },
                    stop() {
                        cancelAnimationFrame(this.cancelId);
                        canvases[3].classList.remove('visible');
                    },
                    animate() {
                        const delta = this.clock.getDelta();
                        const values = this.analyser.getValue();
                        const vertices = this.plane.geometry.attributes.position.array;
                        for (let i = 0; i < vertices.length; i += 3) {
                            const index = Math.floor(i / 3);
                            const value = values[index % values.length] * 10;
                            vertices[i + 2] = value;
                        }
                        this.plane.geometry.attributes.position.needsUpdate = true;
                        this.plane.position.z -= delta * 10;
                        if(this.plane.position.z < -50) this.plane.position.z = 0;
                        this.renderer.render(this.scene, this.camera);
                        this.cancelId = requestAnimationFrame(this.animate.bind(this));
                    }
                },
                matrix: {
                    ctx: canvases[0].getContext('2d'),
                    interval: null,
                    start() {
                        canvases[0].classList.add('visible');
                        this.resize();
                        const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890@#$%^&*()*&^%+-/~{[|`]}アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';
                        const fontSize = 16;
                        const columns = Math.floor(canvases[0].width / fontSize);
                        const drops = Array(columns).fill(1);
                        if(sounds.matrix) new Tone.Loop(t => sounds.matrix.triggerAttack(Tone.Frequency(Math.random() * 24 + 48, "midi"), t), "16n").start(0);
                        if(sounds.bgmMatrix) sounds.bgmMatrix.start(0);
                        const draw = () => {
                            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.04)';
                            this.ctx.fillRect(0, 0, canvases[0].width, canvases[0].height);
                            this.ctx.fillStyle = '#0F0'; this.ctx.font = fontSize + 'px monospace';
                            for (let i = 0; i < drops.length; i++) {
                                const text = chars.charAt(Math.floor(Math.random() * chars.length));
                                this.ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                                if (drops[i] * fontSize > canvases[0].height && Math.random() > 0.975) drops[i] = 0;
                                drops[i]++;
                            }
                        };
                        this.interval = setInterval(draw, 33);
                        return Promise.resolve();
                    },
                    stop() {
                        clearInterval(this.interval);
                        if(sounds.bgmMatrix) sounds.bgmMatrix.stop(0);
                    },
                    resize() {
                        canvases[0].width = window.innerWidth;
                        canvases[0].height = window.innerHeight;
                    }
                }
            };

            activationButton.addEventListener('click', async () => {
                activationButton.disabled = true;
                uiOverlay.classList.remove('visible');
                await new Promise(res => setTimeout(res, 500));
                uiOverlay.style.pointerEvents = 'none';
                activationButton.style.display = 'none';
                uiOverlay.classList.add('visible');

                try {
                    await Tone.start();
                    setupSounds();
                    Tone.Transport.start();
                    
                    const sequence = [
                        { text: "システム認証を開始します...", duration: 2000, anim: animations.circuit, action: null },
                        { text: "AIを起動します", duration: 2000, anim: null, action: null },
                        { text: "生体認証シーケンスを起動...", duration: 4000, anim: animations.biometricScan, action: null },
                        { text: "認証成功。本人確認が完了しました。", duration: 2000, anim: null, action: () => activeAnimation.setSuccess() },
                        { text: "創造領域へのアクセスを許可します", duration: 4000, anim: animations.creatorWorld, action: null },
                        { text: "音世界へのアクセスを許可します", duration: 4000, anim: animations.musicWorld, action: null },
                        { text: "メインシステムに接続します", duration: 2000, anim: null, action: null },
                        { text: "", duration: 4000, anim: animations.matrix, action: null },
                    ];

                    for (const step of sequence) {
                        if (step.anim) await switchAnimation(step.anim);
                        if (step.action) step.action();
                        
                        if (sounds.access && Tone.context.state === 'running' && step.text) {
                            sounds.access.triggerAttackRelease("C5", "8n");
                        }
                        await typeWriter(step.text, infoText);
                        await new Promise(res => setTimeout(res, step.duration));
                        
                        if (sequence.indexOf(step) < sequence.length - 1) {
                            infoText.classList.add('fade-out');
                            await new Promise(res => setTimeout(res, 500));
                            infoText.innerHTML = '';
                            infoText.classList.remove('fade-out');
                        }
                    }
                    
                    await typeWriter("接続完了", infoText);
                    // You can add a redirect or other action here
                } catch (error) {
                    console.error("Opening sequence failed:", error);
                    // Fallback to show content if animation fails
                }
            });

            // Show the activation button
            uiOverlay.classList.add('visible');
        });
    </script>
</body>
</html>